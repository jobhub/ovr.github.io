Сейчас каждый программист слышал о компиляторах и виртуальных машинах, но не каждый осилили прочитать и оформить для себя плюсы и минусы.
Для того что бы подобраться к видам оптимизаций с начало мы должны прояснить все виды компиляции/интерпретации исходного кода.

## Виды трансляция программного кода

Языки программирования изначально были созданы для упрощения записи различных алгоритмов на определенном человеку понятном языке. Если напрячь память мы можем вспомнить что первым языком который мы можем выделить будет Фортран.
Как говорить википедия "Фортра́н (Fortran) — первый язык программирования высокого уровня, имеющий транслятор. Я хочу обратить ваше внимание на слово транслятор так как не каждый язык является компилируемый и понятие транслятор является общей для компиляторов/трансляторов.

#### В итоге процесс трансляции программы может протекать по двум путям это:

###Компиляция

Это трансляция программы, составленной на исходном языке высокого уровня, в эквивалентную программу на низкоуровневом языке, близком машинному коду. Происходит она единожды и в результате мы имеем бинарный файл или байт-код запускаемые через программу.
Давайте вспомним характерных представителей этих языков С/С++, Objective-C, Pascal/Delphi, Java.

Но тут стоит учесть, что выделяют еще два подтипа компиляции:
- Компиляция (дающий бинарный файл)
- Динамическая компиляция (JIT дающий байт-код)

Примеры языков:
- C/C++
- Pascal/Delphi
- Java

Сейчас некоторые люди возможно спросят про себя, а почему Java? Так только потому что программа на java сначала компилируется компилятором javac а только потом скомпилированный машинных код запускается на JVM (Java Virtual Machine).

###Интерпретация

Это анализ кода на входном языке с одновременным выполнением (интерпретацией) кода как правило в виртуальной машине.

Примеры языков:
- PHP
- Ruby
- Perl
- Lua
- Lisp
- Bash

Можно заметить, что интерпретатор непосредственно выполняет действия, связанные с определением или преобразованием объектов программы, а компилятор - переводит их на другой (не обязательно машинный язык).

## Виды способов оптимизации (по среде воздействия)

После того как мы прояснили виды трансляции программного коды мы можем приступит к видам оптимизаций.

-	AOT (Ahead-of-Time) - переводиться как "перед исполнениям". АОТ компиляция проходит с минимальной нагрузкой на систему. Процесс оптимизации полностью выполняется перед выполнением программы.

	Примеры:

	- С/C++
	- Zephir
	- Javac (компилятор java)

- JIT (Just-in-time) - это вид динамической компиляции, созданный для увеличения производительности программных систем, использующих байт-код, путем компиляции байт-кода в машинный код непосредственно во время работы программы. Этот вид компиляции задействован в VM и backend компиляторах.

	- JVM
	- Zephir runtime
	- Javascript
	- .Net
	- PHP 7

	Хочется отметить наличия open source jit компиляторов: LLVM и GNU Lightning которые также могут быть использованы для создания JIT.

## Сравнение производительности

С начало я хотел сравнить JAVA (JIT) и C++ (AOT) но сравнение было бы не корректным. Производительность JIT-компиляторов по сравнению с универсальными компиляторами в некоторых искусственных специально подобранных тестах оказалась сравнимой, но на практике если и наблюдается прирост, то не большой.
Тема весьма большая и спорная требующая большой обьем тестов но осветить ее постораюсь в следущей статье про JIT.

## Плюсы и минусы

Перед тем как сделать свой вывод я бы хотел сначала вспомнить о плюсах и минусах JIT

Плюсы:
+ Как правило к виртуальной машине идет красивая утилита для просмотра производительности и потребления ресурсов

Минусы:
- Тратиться пусть и минимальная скорость на оптимизацию, но тратиться.
- Размер программы (программа требует установки фреймворка и виртуальной машины в систему).

А так же остались вещи которые можно отнести как к плюсам, так и к минусам:
- Оптимизация (часть программ получают хороший выйгрыш, а часть уходят в минус)

## Мое мнение относительно JIT

Мое мнение по поводу JIT сейчас сводиться скорее к нейтральному так как под новой модной технологие не лежит фундамента доказывающие превосходную оптимизацию на реально больших приложениях.